plugins {
    id 'net.researchgate.release' version '2.6.0'
    id 'org.hidetake.ssh' version '2.11.2'
    id 'java'
    id 'maven-publish'
    id 'signing'
}
java {
    sourceCompatibility = JavaVersion.VERSION_17
}

remotes {
    rasPi {
        host = project.findProperty("RasPiHost")
        user = project.findProperty("RasPiUser")
        if(project.hasProperty("RasPiKey")){
            identity = file(project.findProperty("RasPiKey"))
        }else {
            password = project.findProperty("RasPiPassword")
        }
        fileTransfer = "scp"
        jschLog = true
        logging = 'slf4j'
    }
}

group = 'com.github.mbelling'
//flag to disable signing if keyInfo ain't present
boolean doSigning = project.hasProperty('signing.keyId')
        && project.hasProperty('signing.password')
        && project.hasProperty('signing.secretKeyRingFile');

sourceSets {
    main {
        java {
            // Get the generated source from SWIG
            srcDirs('build/generatedSource/java')
        }
        resources {
            // Get the native .so file
            srcDirs('build/nativeLib/')
        }
    }
}

jar {
    from sourceSets.main.output
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.slf4j:slf4j-api:1.7.32'

    testImplementation 'junit:junit:4.13.1'
}

tasks.register('installSwigOnPi'){
    description = 'try to install swig on the raspi'
    def swigDir = "~/rpi_ws281x_build/swigInstall"
    doLast{
        ssh.run{
            session(remotes.rasPi){
                println("ATEMPTING TO INSTALL SWIG")
                execute "mkdir -p $swigDir"
                put (from:'install-swig-on-pi.sh', into: swigDir)
                execute "cd $swigDir; chmod +x install-swig-on-pi.sh"
                execute("cd $swigDir; bash install-swig-on-pi.sh 1>&2") //re-route stdout to stderr so the user sees all the log output
                println("SUCCESS!")
            }
        }
    }
}

def remoteBuildDir = project.findProperty("RasPiRemoteBuildDir")
tasks.register('buildNativeOnPi') {
    description = 'build native lib on remote pi'
    def preamble = "[buildNativeOnPi] -"
    def scriptName = "src/scripts/createNativeLib.sh"
    doLast {
        ssh.run {
            session(remotes.rasPi) {
                println("$preamble make build dir in case it doesn't exists")
                execute "mkdir -p $remoteBuildDir"
                println("$preamble Copy all files...")
                put from: 'src/', into: "$remoteBuildDir/"

                //remove windows line breaks
                //execute "cd $remoteBuildDir; tr -d '\\r' < scripts/createNativeLib.sh > scripts/createNativeLib.sh"
                execute "cd $remoteBuildDir; chmod +x $scriptName"
                //now build
                println("$preamble Execute build script...")
                execute("cd $remoteBuildDir; bash $scriptName 1>&2") //re-route stdout to stderr so the user sees all the log output
                println("$preamble Copy generated artifacts back")
                get from: "$remoteBuildDir/build", into: '.'

                println("$preamble All Done! Try ./gradlew assemble")
            }
        }

    }
}
tasks.register('finalizeBuildNative') {
    doLast {
        ssh.run {
            session(remotes.rasPi) {

            }
        }

    }
}

tasks.buildNativeOnPi.finalizedBy('finalizeBuildNative')

task buildNativeLib(type: Exec) {
    description = "Build the native libraries for arm"

    commandLine 'bash', '-c', 'mkdir -p build/nativeLib && bash src/scripts/createNativeLibLocal.sh'
}

compileJava.dependsOn buildNativeLib

tasks.register('checkSharedLibrary') {
    description = "Check if the shared library exists in the desired location"

    doLast {
        def libraryFile = file('build/nativeLib/libws281x.so')

        if (!libraryFile.exists()) {
            throw new GradleException("Shared library is missing in the desired location. Consult README and try ./gradlew buildNativeLib or ./gradlew buildNativeOnPi")
        }
    }
}

compileJava.dependsOn checkSharedLibrary

java {
    withJavadocJar()
    withSourcesJar()
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            customizePom(pom)
            groupId project.group
            artifactId project.name
            version project.version
            from components.java
            pom {
                withXml {
                    def pomFile = file("${project.buildDir}/generated-pom.xml")
                    writeTo(pomFile)
                    if (doSigning) {
                        def pomAscFile = signing.sign(pomFile).signatureFiles[0]
                        artifact(pomAscFile) {
                            classifier = null
                            extension = 'pom.asc'
                        }
                    }
                }
            }

            if (doSigning) {
                // create the signed artifacts
                project.tasks.signArchives.signatureFiles.each {
                    artifact(it) {
                        def matcher = it.file =~ /-(sources|javadoc)\.jar\.asc$/
                        if (matcher.find()) {
                            classifier = matcher.group(1)
                        } else {
                            classifier = null
                        }
                        extension = 'jar.asc'
                    }
                }
            }
        }
    }
    repositories {
        maven {
            name = "maven"
            credentials(PasswordCredentials) {
                username project.property("MAVEN_USERNAME")
                password project.property("MAVEN_PASSWORD")
            }
            url = project.property("MAVEN_URL")
        }
    }
}

def customizePom(pom) {
    pom.withXml {
        def root = asNode()
        // eliminate test-scoped dependencies (no need in maven central POMs)
        root.dependencies.removeAll { dep ->
            dep.scope == "test"
        }
        // add all items necessary for maven central publication
        root.children().last() + {
            resolveStrategy = Closure.DELEGATE_FIRST
            description 'Java wrapper for rpi_ws281x library using SWIG'
            name 'rpi-ws281x-java'
            url 'https://github.com/rpi-ws281x/rpi-ws281x-java'
            organization {
                name 'rpi-ws281x'
                url 'https://github.com/rpi-ws281x/'
            }
            issueManagement {
                system 'GitHub'
                url 'https://github.com/rpi-ws281x/rpi-ws281x-java/issues'
            }
            licenses {
                license {
                    name 'Apache License 2.0'
                    url 'https://github.com/rpi-ws281x/rpi-ws281x-java/blob/master/LICENSE'
                    distribution 'repo'
                }
            }
            scm {
                url 'https://github.com/rpi-ws281x/rpi-ws281x-java'
                connection 'scm:git:git://github.com/rpi-ws281x/rpi-ws281x-java.git'
                developerConnection 'scm:git:ssh://git@github.com:rpi-ws281x/rpi-ws281x-java.git'
            }
            developers {
                developer {
                    name "Matthew Bellinger"
                }
                developer {
                    name "MNG"
                    roles {
                        role "Update and Improvements like added checks, examples and increased usability"
                    }
                }
            }
        }
    }
}

// Check if signing properties are defined in gradle.properties
if (doSigning) {
    signing {
        sign configurations.archives
    }

    tasks.named 'publishMavenJavaPublicationToMavenLocal' {
        dependsOn project.tasks.named 'signArchives'
    }
    tasks.named 'publishMavenJavaPublicationToMavenRepository' {
        dependsOn project.tasks.named 'signArchives'
    }
}

model {
    tasks.generatePomFileForMavenJavaPublication {
        destination = layout.buildDirectory.file("generated-pom.xml")
    }
}
